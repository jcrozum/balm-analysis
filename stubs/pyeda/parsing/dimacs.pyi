"""
This type stub file was generated by pyright.
"""

from pyeda.parsing import lex
from pyeda.parsing.token import IntegerToken, KeywordToken, OperatorToken, PunctuationToken

"""
DIMACS

For more information on the input formats,
see "Satisfiability Suggested Format",
published May 1993 by the Rutgers Center for Discrete Mathematics (DIMACS).

Also, see the proceedings of the International SAT Competition
(http://www.satcompetition.org) for information and CNF examples.

Exceptions:
    Error

Interface Functions:
    parse_cnf
    parse_sat
"""
class Error(Exception):
    """An error happened during parsing a DIMACS file"""
    ...


class KW_p(KeywordToken):
    """DIMACS 'p' preamble token"""
    ...


class KW_cnf(KeywordToken):
    """DIMACS 'cnf' token"""
    ...


class KW_sat(KeywordToken):
    """DIMACS 'sat' token"""
    ...


class KW_satx(KeywordToken):
    """DIMACS 'satx' token"""
    ...


class KW_sate(KeywordToken):
    """DIMACS 'sate' token"""
    ...


class KW_satex(KeywordToken):
    """DIMACS 'satex' token"""
    ...


class OP_not(OperatorToken):
    """DIMACS '-' operator"""
    ASTOP = ...


class OP_or(OperatorToken):
    """DIMACS '+' operator"""
    ASTOP = ...


class OP_and(OperatorToken):
    """DIMACS '*' operator"""
    ASTOP = ...


class OP_xor(OperatorToken):
    """DIMACS 'xor' operator"""
    ASTOP = ...


class OP_equal(OperatorToken):
    """DIMACS '=' operator"""
    ASTOP = ...


class LPAREN(PunctuationToken):
    """DIMACS '(' token"""
    ...


class RPAREN(PunctuationToken):
    """DIMACS ')' token"""
    ...


class CNFLexer(lex.RegexLexer):
    """Lexical analysis of CNF strings"""
    def ignore(self, text): # -> None:
        """Ignore this text."""
        ...
    
    def keyword(self, text): # -> None:
        """Push a keyword onto the token queue."""
        ...
    
    def operator(self, text): # -> None:
        """Push an operator onto the token queue."""
        ...
    
    @lex.action(IntegerToken)
    def integer(self, text): # -> int:
        """Push an integer onto the token queue."""
        ...
    
    RULES = ...
    KEYWORDS = ...
    OPERATORS = ...


def parse_cnf(s, varname=...): # -> tuple[Literal['and'], ...]:
    """
    Parse an input string in DIMACS CNF format,
    and return an expression abstract syntax tree.

    Parameters
    ----------
    s : str
        String containing a DIMACS CNF.

    varname : str, optional
        The variable name used for creating literals.
        Defaults to 'x'.

    Returns
    -------
    An ast tuple, defined recursively:

    ast := ('var', names, indices)
         | ('not', ast)
         | ('or', ast, ...)
         | ('and', ast, ...)

    names := (name, ...)

    indices := (index, ...)
    """
    ...

class SATLexer(lex.RegexLexer):
    """Lexical analysis of SAT strings"""
    def ignore(self, text): # -> None:
        """Ignore this text."""
        ...
    
    def keyword(self, text): # -> None:
        """Push a keyword onto the token queue."""
        ...
    
    def operator(self, text): # -> None:
        """Push an operator onto the token queue."""
        ...
    
    def punct(self, text): # -> None:
        """Push punctuation onto the token queue."""
        ...
    
    @lex.action(IntegerToken)
    def integer(self, text): # -> int:
        """Push an integer onto the token queue."""
        ...
    
    RULES = ...
    KEYWORDS = ...
    OPERATORS = ...
    PUNCTUATION = ...


SAT_GRAMMAR = ...
_SAT_TOKS = ...
def parse_sat(s, varname=...): # -> tuple[Literal['var'], tuple[Unknown], tuple[Unknown]] | tuple[Literal['not'], tuple[Literal['var'], tuple[Unknown], tuple[Unknown]]] | tuple[Literal['not'], Unknown] | tuple[Unknown, ...]:
    """
    Parse an input string in DIMACS SAT format,
    and return an expression.
    """
    ...

