"""
This type stub file was generated by pyright.
"""

import os

from typing import Generator, Iterator


from pyeda.boolalg import boolfunc
from pyeda.util import cached_property
from pyparsing import Any

"""
The :mod:`pyeda.boolalg.expr` module implements
Boolean functions represented as expressions.

Data Types:

abstract syntax tree
   A nested tuple of entries that represents an expression.
   It is defined recursively::

      ast := ('const', bool)
           | ('lit', uniqid)
           | (nary, ast, ...)
           | ('not', ast)
           | ('impl', ast, ast)
           | ('ite', ast, ast, ast)

      bool := 0 | 1

      uniqid := nonzero int

      nary := 'or'
            | 'and'
            | 'xor'
            | 'eq'

Interface Functions:

* :func:`exprvar` --- Return a unique Expression variable
* :func:`expr` --- Convert an arbitrary object into an Expression
* :func:`ast2expr` --- Convert an abstract syntax tree to an Expression
* :func:`expr2dimacscnf` --- Convert an expression into an equivalent DIMACS CNF
* :func:`upoint2exprpoint` --- Convert an untyped point into an Expression point

* :func:`Not` --- Expression negation operator
* :func:`Or` --- Expression disjunction (sum, OR) operator
* :func:`And` --- Expression conjunction (product, AND) operator

* :func:`Xor` --- Expression exclusive or (XOR) operator
* :func:`Equal` --- Expression equality operator
* :func:`Implies` --- Expression implication operator
* :func:`ITE` --- Expression If-Then-Else (ITE) operator

* :func:`Nor` --- Expression NOR (not OR) operator
* :func:`Nand` --- Expression NAND (not AND) operator
* :func:`Xnor` --- Expression XNOR (not XOR) operator
* :func:`Unequal` --- Expression inequality (not EQUAL) operator

* :func:`OneHot0`
* :func:`OneHot`
* :func:`NHot`
* :func:`Majority`
* :func:`AchillesHeel`
* :func:`Mux`

Interface Classes:

* :class:`Expression`

  * :class:`Atom`

    * :class:`Constant`

      * Zero
      * One

    * :class:`Literal`

      * :class:`Complement`
      * :class:`Variable`

  * :class:`Operator`

    * :class:`NaryOp`

      * :class:`OrOp`
      * :class:`AndOp`
      * :class:`XorOp`
      * :class:`EqualOp`

    * :class:`NotOp`
    * :class:`ImpliesOp`
    * :class:`IfThenElseOp`

* :class:`NormalForm`

  * :class:`DisjNormalForm`
  * :class:`ConjNormalForm`

    * :class:`DimacsCNF`
"""
if os.getenv('READTHEDOCS') == 'True':
    exprnode = ...
else:
    ...
_LITS = ...
_ASSUMPTIONS = ...


def exprvar(name, index=...) -> Variable:
    r"""Return a unique Expression variable.

    A Boolean *variable* is an abstract numerical quantity that may assume any
    value in the set :math:`B = \{0, 1\}`.
    The ``exprvar`` function returns a unique Boolean variable instance
    represented by a logic expression.
    Variable instances may be used to symbolically construct larger expressions.

    A variable is defined by one or more *names*,
    and zero or more *indices*.
    Multiple names establish hierarchical namespaces,
    and multiple indices group several related variables.
    If the ``name`` parameter is a single ``str``,
    it will be converted to ``(name, )``.
    The ``index`` parameter is optional;
    when empty, it will be converted to an empty tuple ``()``.
    If the ``index`` parameter is a single ``int``,
    it will be converted to ``(index, )``.

    Given identical names and indices, the ``exprvar`` function will always
    return the same variable:

    >>> exprvar('a', 0) is exprvar('a', 0)
    True

    To create several single-letter variables:

    >>> a, b, c, d = map(exprvar, 'abcd')

    To create variables with multiple names (inner-most first):

    >>> fifo_push = exprvar(('push', 'fifo'))
    >>> fifo_pop = exprvar(('pop', 'fifo'))

    .. seealso::
       For creating arrays of variables with incremental indices,
       use the :func:`pyeda.boolalg.bfarray.exprvars` function.
    """
    ...


_KIND2EXPR = ...


def expr(obj: Any, simplify: bool = ...) -> Expression | Variable | _One | _Zero:
    """Convert an arbitrary object into an Expression."""
    ...


def ast2expr(ast) -> Variable:
    """Convert an abstract syntax tree to an Expression."""
    ...


def expr2dimacscnf(ex) -> tuple[dict[Literal, Literal], DimacsCNF]:
    """Convert an expression into an equivalent DIMACS CNF."""
    ...


def expr2dimacssat(ex) -> str:
    """Convert an expression into an equivalent DIMACS SAT string."""
    ...


def upoint2exprpoint(upoint) -> dict[Literal, int]:
    """Convert an untyped point into an Expression point.

    .. seealso::
       For definitions of points and untyped points,
       see the :mod:`pyeda.boolalg.boolfunc` module.
    """
    ...


def Not(x: Expression, simplify: bool = ...) -> Expression:
    """Expression negation operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Or(*xs: Expression, simplify: bool = ...) -> Expression:
    """Expression disjunction (sum, OR) operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def And(*xs: Expression, simplify: bool = ...) -> Expression:
    """Expression conjunction (product, AND) operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Xor(*xs: Expression, simplify: bool = ...) -> Expression:
    """Expression exclusive or (XOR) operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Equal(*xs: Expression, simplify: bool = ...) -> Expression:
    """Expression equality operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Implies(p: Expression, q: Expression, simplify: bool = ...) -> Expression:
    """Expression implication operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def ITE(s: Expression, d1: Expression, d0: Expression, simplify: bool = ...) -> Expression:
    """Expression If-Then-Else (ITE) operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Nor(*xs: Expression, simplify: bool = ...) -> Expression:
    """Expression NOR (not OR) operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Nand(*xs: Expression, simplify: bool = ...) -> Expression:
    """Expression NAND (not AND) operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Xnor(*xs: Expression, simplify: bool = ...) -> Expression:
    """Expression exclusive nor (XNOR) operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Unequal(*xs: Expression, simplify: bool = ...) -> Expression:
    """Expression inequality operator

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def OneHot0(*xs: Expression, simplify: bool = ..., conj: bool =...):
    """
    Return an expression that means
    "at most one input function is true".

    If *simplify* is ``True``, return a simplified expression.

    If *conj* is ``True``, return a CNF.
    Otherwise, return a DNF.
    """
    ...


def OneHot(*xs: Expression, simplify: bool = ..., conj: bool=...):
    """
    Return an expression that means
    "exactly one input function is true".

    If *simplify* is ``True``, return a simplified expression.

    If *conj* is ``True``, return a CNF.
    Otherwise, return a DNF.
    """
    ...


def NHot(n: int, *xs: Expression, simplify: bool = ...):
    """
    Return an expression that means
    "exactly N input functions are true".

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Majority(*xs: Expression, simplify: bool = ..., conj=...):
    """
    Return an expression that means
    "the majority of input functions are true".

    If *simplify* is ``True``, return a simplified expression.

    If *conj* is ``True``, return a CNF.
    Otherwise, return a DNF.
    """
    ...


def AchillesHeel(*xs: Expression, simplify: bool = ...):
    r"""
    Return the Achille's Heel function, defined as:
    :math:`\prod_{i=0}^{n/2-1}{X_{2i} + X_{2i+1}}`.

    If *simplify* is ``True``, return a simplified expression.
    """
    ...


def Mux(fs, sel, simplify: bool = ...):
    """
    Return an expression that multiplexes a sequence of input functions over a
    sequence of select functions.
    """
    ...


def ForAll(vs, ex):
    """
    Return an expression that means
    "for all variables in *vs*, *ex* is true".
    """
    ...


def Exists(vs, ex):
    """
    Return an expression that means
    "there exists a variable in *vs* such that *ex* is true".
    """
    ...


class _Clause:
    """Helper interface for operators in *clause* form."""
    ...


class _DNF:
    """Helper interface for operators in disjunctive normal form."""
    ...


class _CNF:
    """Helper interface for operators in conjunctive normal form."""
    ...


class Expression(boolfunc.Function):
    """Boolean function represented by a logical expression

    .. seealso::
       This is a subclass of :class:`pyeda.boolalg.boolfunc.Function`

    The ``Expression`` class is useful for type checking,
    e.g. ``isinstance(f, Expression)``.

    Do **NOT** create an Expression using the ``Expression`` constructor.
    """
    ASTOP = ...

    def __init__(self, node) -> None:
        ...

    def __repr__(self) -> str:
        ...

    def __enter__(self):
        ...

    def __exit__(self, exc_type, exc_val, exc_tb):
        ...

    def __invert__(self):
        ...

    def __or__(self, other):
        ...

    def __and__(self, other):
        ...

    def __xor__(self, other):
        ...

    def eq(self, other):
        """Boolean equal operator."""
        ...

    def __rshift__(self, other):
        ...

    def __rrshift__(self, other):
        ...

    # @cached_property
    # def support(self): # -> frozenset[Unknown]:
    #     ...
    support: frozenset[Expression] = ...

    # @cached_property
    # def inputs(self): # -> tuple[Any, ...]:
    #     ...
    inputs: tuple[Expression, ...] = ...

    def restrict(self, point):
        ...

    def compose(self, mapping):
        ...

    # -> dict[Unknown, int] | dict[Unknown, Unknown] | None:
    def satisfy_one(self):
        ...

    # -> Generator[dict[Unknown, int] | dict[Unknown, Unknown] | Unknown, None, None]:
    def satisfy_all(self):
        ...

    def is_zero(self) -> Literal:
        ...

    def is_one(self) -> Literal:
        ...

    @staticmethod
    def box(obj) -> Expression | Variable | _One | _Zero:
        ...

    def to_ast(self):
        """Convert this node to an abstract syntax tree."""
        ...

    def iter_dfs(self) -> Iterator[Expression]:
        """Iterate through all expression nodes in DFS order."""
        ...

    @cached_property
    def depth(self):
        """Return the depth of the expression.

        Expression depth is defined recursively:

        1. An atom node (constant or literal) has zero depth.
        2. A branch node (operator) has depth equal to the maximum depth of
           its children (arguments) plus one.
        """
        ...

    @cached_property
    def size(self):
        """Return the size of the expression.

        1. An atom node (constant or literal) has size one.
        2. A branch node (operator) has size equal to the sum of its children's
           sizes plus one.
        """
        ...

    def is_dnf(self):
        """Return True if the expression is in disjunctive normal form."""
        ...

    def is_cnf(self):
        """Return True if the expression is in conjunctive normal form."""
        ...

    def pushdown_not(self) -> Expression:
        """Return an expression with NOT operators pushed down thru dual ops.

        Specifically, perform the following transformations:
            ~(a | b | c ...) <=> ~a & ~b & ~c ...
            ~(a & b & c ...) <=> ~a | ~b | ~c ...
            ~(s ? d1 : d0) <=> s ? ~d1 : ~d0
        """
        ...

    def simplify(self) -> Expression:
        """Return a simplified expression."""
        ...

    @property
    def simple(self):
        """Return True if the expression has been simplified."""
        ...

    def to_binary(self) -> Expression:
        """Convert N-ary operators to binary operators."""
        ...

    def to_nnf(self) -> Expression:
        """Return an equivalent expression is negation normal form."""
        ...

    def to_dnf(self) -> Expression:
        """Return an equivalent expression in disjunctive normal form."""
        ...

    def to_cnf(self) -> Expression:
        """Return an equivalent expression in conjunctive normal form."""
        ...

    def complete_sum(self) -> Expression:
        """
        Return an equivalent DNF expression that includes all prime
        implicants.
        """
        ...

    def expand(self, vs=..., conj=...) -> Expression:
        """Return the Shannon expansion with respect to a list of variables."""
        ...

    @property
    def cover(self):
        """Return the DNF expression as a cover of cubes."""
        ...

    def encode_inputs(self) -> tuple[dict[Literal, Literal], int]:
        """Return a compact encoding for input variables."""
        ...

    def encode_dnf(self):
        """Encode as a compact DNF."""
        ...

    def encode_cnf(self):
        """Encode as a compact CNF."""
        ...

    def tseitin(self, auxvarname=...) -> Expression:
        """Convert the expression to Tseitin's encoding."""
        ...

    def equivalent(self, other) -> bool:
        """Return True if this expression is equivalent to other."""
        ...

    def to_dot(self, name=...) -> str:
        """Convert to DOT language representation."""
        ...


class Atom(Expression):
    """Atom Expression"""
    ...


class Constant(Atom):
    """Constant Expression"""
    VALUE = ...


class _Zero(Constant, _DNF):
    """Constant Zero"""
    VALUE = ...

    def __bool__(self) -> bool:
        ...

    def __int__(self) -> int:
        ...

    def __str__(self) -> str:
        ...

    def is_zero(self) -> Literal:
        ...


class _One(Constant, _CNF):
    """Constant One"""
    VALUE = ...

    def __bool__(self) -> bool:
        ...

    def __int__(self) -> int:
        ...

    def __str__(self) -> str:
        ...

    def is_one(self) -> Literal:
        ...


Zero = ...
One = ...
_CONSTS = ...


class Literal(Atom, _Clause, _DNF, _CNF):
    """Literal Expression"""
    ASTOP = ...

    def __enter__(self) -> None:
        ...

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        ...


class Complement(Literal):
    """Complement Expression"""

    def __str__(self) -> str:
        ...

    @cached_property
    def uniqid(self):
        """Return a unique integer for this complement.

        The value is the negation of the complement's variable.
        For example, if the uniqid of x1 = 1, then the uniqid of ~x1 = -1.
        """
        ...


class Variable(boolfunc.Variable, Literal):
    """Variable Expression"""

    def __init__(self, bvar) -> None:
        ...


class Operator(Expression):
    """Operator Expression"""
    NAME = ...

    def __str__(self) -> str:
        ...

    # @cached_property
    # def xs(self): # -> tuple[Unknown, ...]:
    #     """Return a tuple of this operator's arguments."""
    #     ...
    xs: tuple[Expression, ...] = ...


class NaryOp(Operator):
    """Operator with N arguments"""
    ...


class OrAndOp(NaryOp, _Clause, _DNF, _CNF):
    """Either an OR or AND operator (a lattice op)"""
    ...


class OrOp(OrAndOp):
    """OR Operator"""
    ASTOP = ...
    NAME = ...


class AndOp(OrAndOp):
    """AND Operator"""
    ASTOP = ...
    NAME = ...

    def __enter__(self) -> None:
        ...

    def __exit__(self, exc_type, exc_val, traceback) -> None:
        ...


class XorOp(NaryOp):
    """XOR Operator"""
    ASTOP = ...
    NAME = ...


class EqualOp(NaryOp):
    """Equal Operator"""
    ASTOP = ...
    NAME = ...


class NotOp(Operator):
    """NOT Operator"""
    ASTOP = ...
    NAME = ...
    # @cached_property
    # def x(self): # -> Any:
    #     """For Not(x), return x."""
    #     ...
    x: Expression = ...


class ImpliesOp(Operator):
    """Implies Operator"""
    ASTOP = ...
    NAME = ...

    @cached_property
    def p(self) -> Any:
        """For Implies(p, q), return p."""
        ...

    @cached_property
    def q(self) -> Any:
        """For Implies(p, q), return q."""
        ...


class IfThenElseOp(Operator):
    """If-Then-Else (ITE) Operator"""
    ASTOP = ...
    NAME = ...

    @cached_property
    def s(self) -> Any:
        """For ITE(s, d1, d0), return s."""
        ...

    @cached_property
    def d1(self) -> Any:
        """For ITE(s, d1, d0), return d1."""
        ...

    @cached_property
    def d0(self) -> Any:
        """For ITE(s, d1, d0), return d0."""
        ...


class NormalForm:
    """Normal form expression"""

    def __init__(self, nvars, clauses) -> None:
        ...

    def __repr__(self) -> str:
        ...

    def __str__(self) -> str:
        ...

    @cached_property
    def nclauses(self) -> int:
        """Return the count of clauses in the CNF."""
        ...

    def invert(self):
        """Return the inverse normal form expression."""
        ...

    def reduce(self) -> NormalForm:
        """Reduce to a canonical form."""
        ...


class DisjNormalForm(NormalForm):
    """Disjunctive normal form expression"""

    def decode(self, litmap):
        """Convert the DNF to an expression."""
        ...

    def invert(self) -> ConjNormalForm:
        ...


class ConjNormalForm(NormalForm):
    """Conjunctive normal form expression"""

    def decode(self, litmap):
        """Convert the CNF to an expression."""
        ...

    def invert(self) -> DisjNormalForm:
        ...

    def satisfy_one(self, assumptions=..., **params) -> dict[Literal, int] | None:
        """
        If the input CNF is satisfiable, return a satisfying input point.
        A contradiction will return None.
        """
        ...

    def satisfy_all(self, **params) -> Generator[dict[Literal, int], None, None]:
        """Iterate through all satisfying input points."""
        ...

    @staticmethod
    def soln2point(soln, litmap) -> dict[Literal, int]:
        """Convert a solution vector to a point."""
        ...


class DimacsCNF(ConjNormalForm):
    """Wrapper class for a DIMACS CNF representation"""

    def __str__(self) -> str:
        ...


ASTOPS = ...
